#include <stdio.h>
#include <string.h>

int main(void)
{
    // printf("%d\n", 10);
    // printf("%lf\n", 2.4);
    // printf("%.1lf\n", 3.33);
    // printf("%.10lf\n", 3.3);

    // printf("%.1lf\n", 1e6);
    // printf("%.7lf\n", 3.14e-5);
    // printf("%le\n", 0.0000314);
    // printf("%.2le\n", 0.0000314);

    // printf("%c\n", 'A');
    // printf("%s\n", "AB");

    // int a;
    // double da;
    // char ch;

    // a = 10;
    // da = 3.5;
    // ch = 'A';

    // printf("%d %.1lf %c \n", a, da, ch);
    //# 리눅스와 맥에서는 long이 8바이트로 인식됨
    //# 보통 현업에서는 정밀제어자료형 int32_t(4바이트), int64_t (8바이트)를 사용

    // unsigned int a;
    // a = -1;
    // printf("%u\n", a); //%u 변환 문자는 부호 비트 고려않함

    //float는 4바이트 double은 8바이트 long double은 환경에따라 4or8바이트
    //long double은 천문학 같은 분야가 아니면 잘 쓰지않음

    //char 배열명[문자열길이 + 1] = 문자열;
    //컴파일러가 문자열 끝에 \0(널 문자)을 자동추가하기 떄문에 문자열 길이는 +1 해줘야함
    //대입 연산자(=) 왼쪽은 변수(l-value)가 와야하므로 상수인 배열명이 오지 못함

    //char 배열에 새로운 문자열 저장하려면 strcpy함수 사용
    //string.h헤더 파일 추가해야함
    // char fruit[20] = "strawberry";
    // strcpy(fruit, "banana");
    // printf("%s\n", fruit);

    //const를 사용해서 변수를 상수처럼 사용가능, 선언과 동시에 초기화
    // const double tax_rate = 0.12; //double은 변수지만 const로 인해 상수로 변해 값변경 불가능

    // int a;
    // double b;
    // char alpha;
    // char bet[20];
    // scanf("%d%lf %c%s", &a, &b, &alpha, bet); // %c앞에 공백을 추가하면 문자를 받을때 공백은 무시하고 문자만 하나 입력받음
    // printf("입력된 값: %d, %.1lf, %c, %s\n", a, b, alpha, bet);

    // int a = 5, b = 5;
    // int pre, post;
    // pre = (++a) * 3; //전위 증감 연산자 = a == 6 -> pre == 18
    // post = (b++) * 3; //후위 증감 연산자 = post == 15 -> b == 6
    // // 하나의 수식에서 변수를 두 번 사용할 때 증감 연산자 사용하면 안됨 ex) (++a) + a + (++a)


    // int a = 30;
    // int res;
    // res = (a > 10) && (a < 20); // 0, 이 식을 10 < a < 20으로 표현하면 왼쪽부터 계산해서 1 < 20으로 참이된다
    // res = (a < 10) || (a > 20); // 1
    // res = !(a >= 30); // 0
    //숏 서킷 룰(short circuit rule): &&와 ||은 좌항 결과만으로 판단될 경우 우항을 계산안함으로서 오류 발행 가능해짐
    //ex) (a < 0) && (++b > 20) 좌항이 거짓일 때 우항에 있는 전위 증감연산자가 실행되지 않음

    // double a = 10.9;
    // int res;
    // res = (int)a;
    // printf("%d\n", res); //res == 10 -> int로 형변환시 소수점 아래 값은 버림
    // // 자동 형변환은 서로 다른 형태의 연산자를 컴파일 하는 과정에서 자동으로 데이터 크기가 큰 값으로 바뀜, 
    // //대입 연산은 메모리에 값을 저장하므로 무조건 좌항의 변수형에 맞춰 저장

    // int a = 10;
    // printf("int형 변수의 크기: %d\n", sizeof(a));
    // //보통 컴파일러에 따라 자료형의 크기가 다른 경우가 있어 자료형을 sizeof의 값에 넣어 크기 확인

    // int res;
    // res = 5;
    // res *= a + 10; // a에 10을 더한 값을 res와 곱한 후 res에 저장
    // printf("%d", res);

    // res = (++a, ++b); //콤마 연산자는 대입 연산자보다 우선순위가 낮으므로 괄호 필요, res에는 b++값이 저장됨

    // res = (a > b) ? (res = a) : (res = b); // a가 b보다 크다라는 조건이 참이면 res에 a대입 거짓이면 b대입
    // 삼항연산자는 const를 사용할때 if-else는 불가능해서 대신해 사용함, 복잡한 코드는 삼항연사자를 사용시 스파게티코드가됨

    //비트연산자는 비트로 정확히 표현할 수 있는 정수에만 사용
    // 비트별 논리곱 연산(&): 두 비트가 모두 1인경우 1
    // 비트별 배타적 논리합 연산(^): 두 비트가 서로 다른 경우 1
    // 비트별 논리합 연산자(|): 두 비트 중에서 하나라도 참이면 1
    // 비트별 부정 연산자(~): 1을 0으로 바꾸고, 0을 1로 바꿈
    // 비트 이동 연산자(<<)(>>): <<은 비트를 왼쪽으로 이동 오른쪽의 남는 비트는 0으로 채움, >>은 오른쪽으로 이동 밀려나는 비트는 삭제
    // 비트 가장 왼쪽은 unsigned로 할당되었다면 0, 아니라면 양수는 0 음수는 1
    // 대입 연산자와 결합해 <<=, &=, ^=, |= 로도 가능 ~은 단항 연산자이므로 불가능

    //연산자 우선순위: 단항 연산자 > 이항 연산자 > 삼항 연산자,
    //산술 연산자 > (비트 이동 연산자) > 관계 연산자 > 논리 연산자
    //같은 우선순위 안에서는 왼쪽부터 실행

    // if (a >= 10){
    //     b = 1;
    // }
    // else if (a >= 0){
    //     b = 2;
    // }
    // else{
    //     b = 3;
    // }

    // switch (rank)
    // {
    //     case 1:
    //         m = 300;
    //         break; //break가 있으면 switch문을 탈출하지만 없으면 rank가 1일때 하위 케이스의 break문까지 충족한걸로 인식
    //     case 2:
    //         m = 200:
    //         break;
    //     case 3:
    //         m = 100;
    //         break;
    //     default: // 블록 안 어디에 위치해도 상관 없으나 보통 마지막에 두어 예외 상황 처리
    //         m = 10;
    //         break;
    // }

    









    return 0;
}